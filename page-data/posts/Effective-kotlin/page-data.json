{"componentChunkName":"component---src-templates-posts-template-index-tsx","path":"/posts/Effective-kotlin","result":{"pageContext":{"currentCategory":"Effective-kotlin","categories":["All","의존성주입","Kotlin","컴포즈내부시리즈","Effective-kotlin"],"edges":[{"node":{"id":"335d1dd6-cdad-5ace-b3ad-de48f1cd8bc2","excerpt":"본 책에 존재하는 코드는 BankAccount에는 계좌에 돈이 얼마나 있는지 나타내는 상태가 있다. 위 코드가 작동 동작에 대해서는 문제가 없지만, 상태를 적절하게 관리하기 위해서는 어려움이 존재한다. 상태를 관리하기 어려운 이유 프로그램을 이해하고 디버그하는데 어려움이 존재한다. 가변성(mutability) 있으면, 코드의 실행을 추적하기 어려움이 존재한다. 멀티스레드 프로그램 상황에서 적절한 동기화가 필요하다. 테스트가 어렵다. 모든 상태를 테스트해야하기에 변경이 많아질수록 더 많은 조합을 테스트해야 한다. 상태 변경이 일어나면, 변경을 다른 부분에 알려야 한다. 정렬해야 하는 리스트에 새로운 가변 값이 추가되면, 리스트를 다시 정렬하라고 알려줘야 한다. 가변성은 생각보다 단점이 많아서 완전하게 제한하는 프로그래밍 언어가 있다. 가변성은 시스템의 상태를 나타내기 위한 중요한 방법이다. 하지만 변경이 일어나야 하는 부분은 신중, 확실하게 결정하고 사용해야 한다. 코틀린에서 가변성…","fields":{"slug":"/effective-kotlin-item-1/"},"frontmatter":{"categories":"Effective-kotlin","title":"item1-가변성을 제한하라","date":"2023.08.20"}},"next":null,"previous":{"fields":{"slug":"/compose-internal-1/"}}}]}},"staticQueryHashes":["1321405810","3649515864"]}