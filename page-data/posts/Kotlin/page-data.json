{"componentChunkName":"component---src-templates-posts-template-index-tsx","path":"/posts/Kotlin","result":{"pageContext":{"currentCategory":"Kotlin","categories":["All","의존성주입","iOS","Kotlin","Swift"],"edges":[{"node":{"id":"49969fc3-7ba3-542e-b459-f6eeefe99780","excerpt":"inline function Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure. A closure is a scope of variables that can be accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead. 은 코틀린에서만 제공하는 키워드입니다. 공식 문서에서 고차함수를 사용하면 패널티가 발생하며, 추가적인 메모리 할당 함수 호출로 런 타임 오버헤드가 발생한다고 합니다. 람다를 사용하게 될 시, 각 함수는 객체로 변환되어 메모리 할당과 가상 호출 단계를 거치게 되고 이 과정 속에서 오버헤드가 발생합니다. 하지만, 은…","fields":{"slug":"/kotlin-inline-function-reified/"},"frontmatter":{"categories":"Kotlin","title":"inline function과 reified","date":"2023.11.22"}},"next":{"fields":{"slug":"/compose-internal-2/"}},"previous":{"fields":{"slug":"/dependency-injection-1/"}}}]}},"staticQueryHashes":["1321405810","3649515864"]}