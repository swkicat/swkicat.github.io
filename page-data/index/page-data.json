{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"6b0abfd5-6928-5bec-a338-73c710a0cade","excerpt":"Hilt 등장 hilt는 안드로이드를 위한 표준적인 DI 솔루션을 제공해준다. hilt는 최초의 안드로이드 표준적인 DI 솔루션이 아니라 개인이나 회사에서 별도로 구현해서 만들기도 했다. 안드로이드 팀은 최초의 개발 언어를 Java로 채택을 했습니다. 그로인해 의존성 주입도 자바의 방식을 많이 따르곤 했다. Java를 위한 의존성 주입 표준 JSR 330 자바 플랫폼에 대한 스펙을 제한하고 규격화한 표준 사양을 의미한다. 자바를 위한 의존성 주입에 대한 표준성 방법을 정의한 내용이다. 대부분 자바의 의존 라이브러리들은 JSR 330 스펙을 충족하며 hilt도 충족하고 있다. DI 솔루션(Android) DI 솔루션으로 Guide, Dagger2, Koin, Hilt가 존재합니다. Guice 안드로이드 이전 의존성 주입 라이브러리 자바를 위한 의존성 주입 런타임에 의존성 주입 리플렉션 기반; 런타임에 로드된 다른 클래스 정보를 가져올 수 있는 장점이 있지만, 비용이 큰 작업을 가지고…","frontmatter":{"categories":"의존성주입","title":"Hilt 등장","emoji":"⛓️","date":"2024.01.27"},"fields":{"slug":"/hilt/"}}},{"node":{"id":"e1e7f05e-3d60-5aca-942b-0993c9b47bd1","excerpt":"의존성 주입이란? 의존성 의존성을 한 문장으로 표현하면 어떤 대상이 참조하는 객체(또는 함수)라고 부를 수 있습니다. 위의 코드를 보면  라고 표현을 합니다. Car의 입장에서 Engine에 의존하고 Engine는 의존성이 됩니다. 의존성 주입 의존성 주입은 대상 객체에 의존성을 제공하는 기술이라고 부를 수 있습니다. Car 클래스 내에서 직접 Engine을 생성하고 있으며, Car는 Engine 인스턴스를 생성하는 책임을 가지고 있습니다. Engine 생성 책임을 제거해보면, 위와 같은 코드로 변경할 수 있습니다. Engine을 외부에서 전달 받을 수 있게 됩니다. Car는 Engine 생성에 대한 책임 없게 됩니다. 위와 같은 설계 패턴을 IoC(제어의 역전) 이라고 부릅니다. 객체 생성의 책임을 내부에서 외부로 뒤집으면서 Engine에 대한 제어를 역전 시킨다는 의미를 가지게 됩니다. 이것을 의존성 주입이라고 부를 수 있습니다. 엔진을 게속해서 생서시켜 주입한다면, Car 객…","frontmatter":{"categories":"iOS","title":"의존성 주입이란","emoji":"⛓️","date":"2024.01.15"},"fields":{"slug":"/dependency-injection-1/"}}},{"node":{"id":"49969fc3-7ba3-542e-b459-f6eeefe99780","excerpt":"inline function Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure. A closure is a scope of variables that can be accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead. 은 코틀린에서만 제공하는 키워드입니다. 공식 문서에서 고차함수를 사용하면 패널티가 발생하며, 추가적인 메모리 할당 함수 호출로 런 타임 오버헤드가 발생한다고 합니다. 람다를 사용하게 될 시, 각 함수는 객체로 변환되어 메모리 할당과 가상 호출 단계를 거치게 되고 이 과정 속에서 오버헤드가 발생합니다. 하지만, 은…","frontmatter":{"categories":"Kotlin","title":"inline function과 reified","emoji":"🧢","date":"2023.11.22"},"fields":{"slug":"/kotlin-inline-function-reified/"}}},{"node":{"id":"bdb2eefd-34f9-5481-b207-c08cbff714e4","excerpt":"컴포즈에서 이용되는 데이터들을 저장하기 위해서 slot table을 활용합니다. Slot Table slot table 은 Gap Buffer 자료구조와 Array 자료구조를 활용한 클래스라고 생각하면 간단하다. 배열의 단점은 사이즈가 고정되어 있고 찾으려면 직접 처음부터 찾아봐야한다. 그로 인해 O(N)이라는 시간복잡도를 가지게 된다. 컴포즈는 리컴포지션이 잦게 발생한다. 모든 연산이 O(N)이 발생한다면, 느려지게 된다. 그래서 O(1) 기대하게 된다. 배열의 단점을 극복하고자 Gap Buffer 자료구조를 활용해 slot table 을 이용한다. 은 Gap Buffer 자료구조를 기반으로 빠른 선형 접근에 최적화된 메모리 구조이다. slot table은 컴포지션에 대한 모든 정보들이 저장된다. slot table은 2가지의 선형 배열을 가지고 있다. 과 이다. group slot table에 특정 도메인에 속한 데이터가 저장되는 범위이다. 예로 들면, State, Modifi…","frontmatter":{"categories":"iOS","title":"Compose Internal (2) - slot table","emoji":"🔎","date":"2023.11.08"},"fields":{"slug":"/compose-internal-2/"}}},{"node":{"id":"f3b4e1f8-6727-528e-a840-54834decfcc8","excerpt":"Positional Memoization Compose는 컴파일러가 함수의 input에 의하여 반환되는 결과를 cache하는 Global Memoization을 가지고 있습니다. 같은 위치에서 input으로 호출되면 같은 output이 나오게됨을 가정하고, 값을 cache하고 재사용하는 방법입니다. composable function은 파라미터로 items과 item을 받아서 find 연산을 진행하고 있습니다. 위 연산을  키워드를 활용하면, items과 item은 slot table에 저장하게 됩니다. 연산을 진행한 result 결과 값도 slot table에 저장됩니다. 한마디로, input과 output이 slot에 저장되게 됩니다. 위치 메모이제이션은 composable 함수가 두 번째 호출할 때 remember에 의해 저장되어 있는 input 값을 보고 새로 들어오는 값과 비교해 변경된 것이 없다면 이전에 저장한 데이터를 활용합니다. 위치 키는 함수의 시그니쳐와 call-…","frontmatter":{"categories":"iOS","title":"Compose Internal (3) - 위치메모이제이션","emoji":"🔎","date":"2023.11.08"},"fields":{"slug":"/compose-internal-3/"}}},{"node":{"id":"94e17da8-3625-5c98-a8e4-faebd1262a37","excerpt":"Compose 분류 작업 방향에 따라  ➡️  ➡️  Compose Compiler와 Compose Runtime은 코틀린 네이티브에 속하기 때문에 멀티 플랫폼으로 사용 가능하다. 그로 인해서, Compose UI는 각각의 플랫폼에 따라서 다른 UI 규칙을 가져가게 된다. 컴포즈 시스템의 기본 컴포즈 시스템은  과  을 기반으로 작동한다. 은 멱등성 개념과 비슷하다. 같은 위치에서 input으로 호출되면 같은 output이 나오는 것이며, 값을 캐싱하고 재사용하는 기술이다. 은 발생한 컴포지션에 대한 정보들을 저장되는 공간이며  자료구조에  라는 개념을 더해서 활용한다. 컴포저블이 UI로 그려지는 원리  -  -  과정을 통해 컴포저블이 UI로 그려지게 된다. 컴포지션 slot table에 초기 gap이 할당되고 최초 상태의 컴포저블 데이터가 등록되는 상태 리컴포지션은 컴포지션 이후 상태가 변경으로 컴포저블이 변경되어 slot table에 값을 업데이트하는 것을 지칭한다. 방출 slo…","frontmatter":{"categories":"iOS","title":"Compose Internal (1) - 기본 시스템 원리","emoji":"🔎","date":"2023.11.07"},"fields":{"slug":"/compose-internal-1/"}}},{"node":{"id":"335d1dd6-cdad-5ace-b3ad-de48f1cd8bc2","excerpt":"본 책에 존재하는 코드는 BankAccount에는 계좌에 돈이 얼마나 있는지 나타내는 상태가 있다. 위 코드가 작동 동작에 대해서는 문제가 없지만, 상태를 적절하게 관리하기 위해서는 어려움이 존재한다. 상태를 관리하기 어려운 이유 프로그램을 이해하고 디버그하는데 어려움이 존재한다. 가변성(mutability) 있으면, 코드의 실행을 추적하기 어려움이 존재한다. 멀티스레드 프로그램 상황에서 적절한 동기화가 필요하다. 테스트가 어렵다. 모든 상태를 테스트해야하기에 변경이 많아질수록 더 많은 조합을 테스트해야 한다. 상태 변경이 일어나면, 변경을 다른 부분에 알려야 한다. 정렬해야 하는 리스트에 새로운 가변 값이 추가되면, 리스트를 다시 정렬하라고 알려줘야 한다. 가변성은 생각보다 단점이 많아서 완전하게 제한하는 프로그래밍 언어가 있다. 가변성은 시스템의 상태를 나타내기 위한 중요한 방법이다. 하지만 변경이 일어나야 하는 부분은 신중, 확실하게 결정하고 사용해야 한다. 코틀린에서 가변성…","frontmatter":{"categories":"Swift","title":"item1-가변성을 제한하라","emoji":"🔮","date":"2023.08.20"},"fields":{"slug":"/effective-kotlin-item-1/"}}}]},"site":{"siteMetadata":{"siteUrl":"https://swkicat.github.io","language":"ko","author":{"name":"swkicat","nickname":"swkicat","stack":["iOS","Swift"],"bio":{"email":"siyeon0616@gmail.com","residence":"South Korea","bachelorDegree":""},"social":{"github":"https://github.com/swkicat","linkedIn":"https://www.linkedin.com/in/siwon-kim-02a792178/","resume":""}}}}},"pageContext":{}},"staticQueryHashes":["1186322783","1321405810","3649515864"]}