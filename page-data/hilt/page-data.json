{"componentChunkName":"component---src-templates-post-template-index-tsx","path":"/hilt/","result":{"data":{"cur":{"id":"ade91ac6-3fd1-5b4c-ac3d-42aa1218aa17","html":"<h3 id=\"hilt-등장\" style=\"position:relative;\"><a href=\"#hilt-%EB%93%B1%EC%9E%A5\" aria-label=\"hilt 등장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hilt 등장</h3>\n<p>hilt는 안드로이드를 위한 표준적인 DI 솔루션을 제공해준다.</p>\n<p>hilt는 최초의 안드로이드 표준적인 DI 솔루션이 아니라 개인이나 회사에서 별도로 구현해서 만들기도 했다.</p>\n<p>안드로이드 팀은 최초의 개발 언어를 Java로 채택을 했습니다. 그로인해 의존성 주입도 자바의 방식을 많이 따르곤 했다.</p>\n<h3 id=\"java를-위한-의존성-주입-표준\" style=\"position:relative;\"><a href=\"#java%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%ED%91%9C%EC%A4%80\" aria-label=\"java를 위한 의존성 주입 표준 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java를 위한 의존성 주입 표준</h3>\n<ul>\n<li>JSR 330\n<ul>\n<li>자바 플랫폼에 대한 스펙을 제한하고 규격화한 표준 사양을 의미한다.</li>\n<li>자바를 위한 의존성 주입에 대한 표준성 방법을 정의한 내용이다.</li>\n<li>대부분 자바의 의존 라이브러리들은 JSR 330 스펙을 충족하며 hilt도 충족하고 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"di-솔루션android\" style=\"position:relative;\"><a href=\"#di-%EC%86%94%EB%A3%A8%EC%85%98android\" aria-label=\"di 솔루션android permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DI 솔루션(Android)</h3>\n<p>DI 솔루션으로 Guide, Dagger2, Koin, Hilt가 존재합니다.</p>\n<ol>\n<li><strong>Guice</strong></li>\n</ol>\n<ul>\n<li>안드로이드 이전 의존성 주입 라이브러리</li>\n<li>자바를 위한 의존성 주입</li>\n<li>런타임에 의존성 주입</li>\n<li>리플렉션 기반; 런타임에 로드된 다른 클래스 정보를 가져올 수 있는 장점이 있지만, 비용이 큰 작업을 가지고 있어 앱의 성능이 떨어질 수 있다.</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Dagger2</strong></li>\n</ol>\n<ul>\n<li>자바를 위한 의존성 주입</li>\n<li>컴파일 타임 코드 생성</li>\n<li>Square에서 최초 개발, 이후 구글에서 유지 보수</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Koin</strong></li>\n</ol>\n<ul>\n<li>코틀린를 위한 의존성 주입</li>\n<li>리플렉션 사용; Guice와 동일하게 앱의 퍼포먼스가 떨어질 수 있다.</li>\n<li>서비스 로케이터 패턴</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Hilt</strong></li>\n</ol>\n<ul>\n<li>2020년 6월 최초 출시</li>\n<li>안드로이드만을 위한 솔루션</li>\n<li>Dagger2 기반</li>\n<li>표준 컴포넌트 제공</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- Koin\n  - 런타임 안정성 낮음\n  - 퍼포먼스 낮음\n  - 의존성 관리 어려움\n\n- Dagger2(Hilt)\n  - 런타임 안정성 높음\n  - 퍼포먼스 높음\n  - 의존성 관리 쉬움</code></pre></div>\n<h4 id=\"dagger2\" style=\"position:relative;\"><a href=\"#dagger2\" aria-label=\"dagger2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Dagger2]</h4>\n<ul>\n<li>\n<p>어노테이션 프로세서로 자동 코드 생성</p>\n<ul>\n<li>컴파일 타임에 오류를 체크할 수 있으며, 리플렉션 API를 활용하지 않을 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Hilt 등장 이전에 매우 인기있었던 라이브러리</p>\n</li>\n<li>\n<p>초보자가 학습하기 어려움이 존재한다.</p>\n</li>\n<li>\n<p>높은 자유도를 가지고 있다. 동일한 문제를 해결하는데 있어서 서로 다른 방식으로 문제를 해결할 수 있다는 것이다. 그로 인해 개발자 사이에서 혼발을 유발 시킬 수 있다. 정답은 없더라도 정돈은 필요로 하듯이 Dagger2는 높은 자유도로 필요로 하지 않았다.</p>\n</li>\n<li>\n<p>실제 설문 조사에서 49% 이상의 안드로이드 개발자가 의존성 주입에 대한 가이드에 대답이 존재했다.</p>\n</li>\n</ul>\n<h4 id=\"hilt\" style=\"position:relative;\"><a href=\"#hilt\" aria-label=\"hilt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Hilt]</h4>\n<p>아래 3가지를 DI 라이브러리가 갖춰야할 덕목으로 나타났습니다.</p>\n<ul>\n<li>안드로이드를 위한 확실한 방향성 제시가 필요</li>\n<li>간단한 설정 및 사용방법</li>\n<li>비즈니스 로직에 집중이 가능</li>\n</ul>\n<blockquote>\n<blockquote>\n<p><strong>Hilt의 장점</strong></p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ol>\n<li>Dagger2를 기반으로 안드로이드를 위한 표준화된 의존성 주입 방법 제공을 해줍니다.</li>\n</ol>\n<ul>\n<li>표준 컴포넌트를 제공(:정해진 방법대로 의존성 주입)</li>\n<li>Dagger2의 자유도를 뺏으며 정해진 규칙에 맞춰서 개발</li>\n</ul>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>보일러플레이터 감소</li>\n</ol>\n<ul>\n<li>Hilt가 제공하는 ViewModel.Factory를 통해서 더이상 뷰모델 팩토리를 확장할 필요가 없어짐</li>\n<li>Hilt가 제공하는 테스트용 컴포넌트를 사용해 코드를 30% 정도 줄일 수 있다.</li>\n<li>표준 컴포넌트 사용으로 별도 컴포넌트 정의 불필요</li>\n<li>적은 Dagger 모듈 생성과 중복되는 바인딩 정의 축소</li>\n<li>바이트 코드 변조</li>\n</ul>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>Jetpack과의 통합</li>\n</ol>\n<ul>\n<li>기존 androidx jetpack 라이브러리와 통합이 된다.(ViewModel, Navigation, WorkManager…)</li>\n</ul>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ol start=\"4\">\n<li>테스트 도구 제공</li>\n</ol>\n<ul>\n<li>Hilt 테스트 어노테이션을 제공(@HiltAndroidTest, @UninstallModules, @BindValue, @CustomTestApplication)</li>\n</ul>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ol start=\"5\">\n<li>마이그레이션 API 제공</li>\n</ol>\n<ul>\n<li>손쉬운 마이그레이션 방법 제공</li>\n<li>Hilt는 dagger2 및 dagger2.android와 함께 동작이 가능</li>\n<li>마이그레이션을 위한 다양한 API 제공</li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<ul>\n<li>Hilt는 Dagger2가 갖고 있던 어려움을 개선하기 위해 등장</li>\n<li>다른 솔루션들과 비교해 Hilt는 많은 장점을 갖고 있다.</li>\n<li>손쉬운 사용과 보일러플레이트를 감소시킨다.</li>\n<li>Jetpack 라이브러리와 함께 사용하고 좋다.</li>\n<li>테스트 및 마이그레이션 편의를 위해 다양한 API를 제공한다.</li>\n</ul>","excerpt":"Hilt 등장 hilt는 안드로이드를 위한 표준적인 DI 솔루션을 제공해준다. hilt는 최초의 안드로이드 표준적인 DI 솔루션이 아니라 개인이나 회사에서 별도로 구현해서 만들기도 했다. 안드로이드 팀은 최초의 개발 언어를 Java로 채택을 했습니다. 그로인해 의존성 주입도 자바의 방식을 많이 따르곤 했다. Java를 위한 의존성 주입 표준 JSR 330 자바 플랫폼에 대한 스펙을 제한하고 규격화한 표준 사양을 의미한다. 자바를 위한 의존성 주입에 대한 표준성 방법을 정의한 내용이다. 대부분 자바의 의존 라이브러리들은 JSR 330 스펙을 충족하며 hilt도 충족하고 있다. DI 솔루션(Android) DI 솔루션으로 Guide, Dagger2, Koin, Hilt가 존재합니다. Guice 안드로이드 이전 의존성 주입 라이브러리 자바를 위한 의존성 주입 런타임에 의존성 주입 리플렉션 기반; 런타임에 로드된 다른 클래스 정보를 가져올 수 있는 장점이 있지만, 비용이 큰 작업을 가지고…","frontmatter":{"date":"2024.01.27","title":"Hilt 등장","categories":"의존성주입","emoji":"⛓️"},"fields":{"slug":"/hilt/"}},"next":{"id":"e51095fc-bebf-5cac-96d5-220869220d3d","html":"<h2 id=\"의존성-주입이란\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EC%9D%B4%EB%9E%80\" aria-label=\"의존성 주입이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존성 주입이란?</h2>\n<h3 id=\"의존성\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1\" aria-label=\"의존성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존성</h3>\n<p><strong>의존성</strong>을 한 문장으로 표현하면 어떤 대상이 참조하는 객체(또는 함수)라고 부를 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Engine\n\n<span class=\"token keyword\">class</span> Car <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> engine <span class=\"token operator\">=</span> <span class=\"token function\">Engine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>위의 코드를 보면 <code class=\"language-text\">Car는 Engine에 의존한다(의존적이다)</code> 라고 표현을 합니다.</li>\n<li>Car의 입장에서 Engine에 의존하고 Engine는 의존성이 됩니다.</li>\n</ul>\n<h3 id=\"의존성-주입\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85\" aria-label=\"의존성 주입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존성 주입</h3>\n<p><strong>의존성 주입</strong>은 대상 객체에 의존성을 제공하는 기술이라고 부를 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Engine\n\n<span class=\"token keyword\">class</span> Car <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> engine <span class=\"token operator\">=</span> <span class=\"token function\">Engine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Car 클래스 내에서 직접 Engine을 생성하고 있으며, Car는 Engine 인스턴스를 생성하는 책임을 가지고 있습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Engine\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> engine<span class=\"token operator\">:</span> Engine<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Engine 생성 책임을 제거해보면, 위와 같은 코드로 변경할 수 있습니다.</li>\n<li>Engine을 <strong>외부에서 전달</strong> 받을 수 있게 됩니다.</li>\n<li>Car는 Engine 생성에 대한 <strong>책임 없게</strong> 됩니다.</li>\n</ul>\n<p>위와 같은 설계 패턴을 IoC(제어의 역전) 이라고 부릅니다. 객체 생성의 책임을 내부에서 외부로 뒤집으면서 Engine에 대한 제어를 역전 시킨다는 의미를 가지게 됩니다. 이것을 의존성 주입이라고 부를 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> gasolineCar <span class=\"token operator\">=</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span><span class=\"token function\">GasolineEngine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> dieselCar <span class=\"token operator\">=</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span><span class=\"token function\">DieseEngine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>엔진을 게속해서 생서시켜 주입한다면, Car 객체에는 변경점이 생기지 않게 된다.</li>\n<li>재사용: Car 객체를 변경하지 않게 될 수 있다.</li>\n<li>디커플링: 결합도를 낮춰 준다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> engine<span class=\"token operator\">:</span> Engine<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> battery<span class=\"token operator\">:</span> Battery<span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>위와 같이 필요한 의존성을 외부에서 주입받을 수 있게 되며, 기존 Car 클래스가 가지고 있는 책임들이 줄어들게 된다.</li>\n<li>외부에서 주입해주는 객체들을 보면 하나의 기능만을 책임 줄 수 있는 캡슐화할 수 있도록 단일 책임 원칙을 지킬 수 있게 된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> CarTest <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation builtin\">@Test</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">`Car 테스트`</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> car <span class=\"token operator\">=</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span><span class=\"token function\">FakeEngine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n        <span class=\"token keyword\">val</span> car2 <span class=\"token operator\">=</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span><span class=\"token function\">FakeBrokenEngine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>의존성 주입의 또 다른 장점은 테스트를 쉽게 만들어 준다.</li>\n<li>엔진을 밖에서 주입해주기 때문에 Car 객체의 테스트와 실패를 확인할 수 있게 된다.</li>\n</ul>\n<h3 id=\"injector\" style=\"position:relative;\"><a href=\"#injector\" aria-label=\"injector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Injector</h3>\n<p>Injector는 <strong>의존성을 클라이언트에게 제공하는 역할</strong>이라고 부릅니다.<br>\nInjector는 때로는 Container, Assembler, Provider, Factory라고 부르기도 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Injector <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">getEngine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">Engine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Injector가 없는 경우</span>\n    <span class=\"token keyword\">val</span> engine <span class=\"token operator\">=</span> <span class=\"token function\">Engine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> car <span class=\"token operator\">=</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span>engine<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// Injector가 있는 경우</span>\n    <span class=\"token keyword\">val</span> engine <span class=\"token operator\">=</span> <span class=\"token function\">Injector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getEngine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> car <span class=\"token operator\">=</span> <span class=\"token function\">Car</span><span class=\"token punctuation\">(</span>engine<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>Car는 Engine를 참조</p>\n</li>\n<li>\n<p>Injector는 Engine을 의존</p>\n</li>\n<li>\n<p>Injector는 Car에 주입</p>\n</li>\n<li>\n<p>injector.getEngine()을 통해 새로운 엔진을 계속해서 만들어낼 수 있습니다.</p>\n</li>\n<li>\n<p>만일, 동일한 엔진을 가지고 싶다면, <code class=\"language-text\">val engine = Engine()</code>로 injector 클래스에 만들어서 <code class=\"language-text\">injector.engine</code> 이라는 변수에 접근하면 됩니다.</p>\n</li>\n</ul>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<ul>\n<li>의존성 주입은 클래스간 결합도가 낮아집니다.</li>\n<li>재상용성이 가능하다.</li>\n<li>보일러플레이트 감소한다.</li>\n<li>테스트가 간편해진다.</li>\n<li>자원공유 하는 등의 의존성 관리가 용이하다.</li>\n</ul>","frontmatter":{"date":"2024.01.15","title":"의존성 주입이란","categories":"iOS","emoji":"⛓️"},"fields":{"slug":"/dependency-injection-1/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://swkicat.github.io","comments":{"utterances":{"repo":"taewooyo/gatsby-blog"}}}}},"pageContext":{"slug":"/hilt/","nextSlug":"/dependency-injection-1/","prevSlug":""}},"staticQueryHashes":["1321405810","3649515864"]}